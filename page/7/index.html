<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://blog.bookbook.in').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="关系、健康、自由，是我的追求。">
<meta property="og:type" content="website">
<meta property="og:title" content="Book Book, Come in~">
<meta property="og:url" content="http://blog.bookbook.in/page/7/index.html">
<meta property="og:site_name" content="Book Book, Come in~">
<meta property="og:description" content="关系、健康、自由，是我的追求。">
<meta property="article:author" content="知明所以">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.bookbook.in/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Book Book, Come in~</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Book Book, Come in~</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">知明所以的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2014/03/29/%E6%8A%80%E6%9C%AF/[cocos2dx]%E8%AE%A9CCScrollView%E6%94%AF%E6%8C%81%E5%88%86%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2014/03/29/%E6%8A%80%E6%9C%AF/%5Bcocos2dx%5D%E8%AE%A9CCScrollView%E6%94%AF%E6%8C%81%E5%88%86%E9%A1%B5/" class="post-title-link" itemprop="url">[cocos2dx]让CCScrollView支持分页</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2014-03-29T00:00:00+08:00">2014-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>简介： 做过<code>IOS</code>开发的朋友, 肯定知道<code>UIScrollView</code>有一个<code>isPaged</code>属性. 当设置其为<code>true</code>的时候, 滑动会自动分页. 即, 每次滑动之后, 会停止在整页的位置. 当开始介入<code>cocos2dx</code>开发的时候, 却发现跟<code>UIScrollView</code>接口十分相似的<code>CCScrollView</code>却没有这个分页属性. 于是手动实现了一个. </p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在常见的图形引擎中, 滑动组件的定义里有两个重要的概念</p>
<ul>
<li><code>viewSize</code>: 这个大小值得是组件占用屏幕的大小. 即实际大小.</li>
<li><code>contentSize</code>: 这个大小是一个虚拟的大小. 我们之所以要滚动, 必然是因为需要展示的内容比现实的屏幕空间大. 我们需要滚动屏幕, 才能浏览到所有的显示内容. 这个<code>contentSize</code>即是我们虚拟出来的, 需要展示的所有内容加起来的大小.</li>
<li>分页: 最典型的例子就是iPhone的主界面. 我们不能任意指定一个位置, 让滑动固定在那里. 它要么停留在第一页, 要么停留在第二页, 不会是第0.5页. 每一页的大小是<code>viewSize</code>决定的. 那么总页数就是<code>total_page_count = ceil(viewSize / contentSize )</code></li>
</ul>
<h2 id="CCScrollView源码查看"><a href="#CCScrollView源码查看" class="headerlink" title="CCScrollView源码查看"></a>CCScrollView源码查看</h2><p>我们知道, <code>cocos2dx</code>的触摸都是通过<code>CCTouchDelegate</code>来实现的. 如果对<code>cocos2dx</code>的touch机制不熟悉的, 可以参考博客.  </p>
<h3 id="简单介绍ccTouchBegan方法的功能"><a href="#简单介绍ccTouchBegan方法的功能" class="headerlink" title="简单介绍ccTouchBegan方法的功能:"></a>简单介绍ccTouchBegan方法的功能:</h3><p><code>ccTouchBegan</code>是<code>cocos2dx</code>touch机制的第一个方法. 这个方法的接口如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool CCScrollView::ccTouchBegan(CCTouch* touch, CCEvent* event)</span><br></pre></td></tr></table></figure>
<p>返回的<code>bool</code>值, 告诉<code>cocos2dx</code>中touch事件的管理者<code>CCTouchDispatcher</code>, 当前组件是否处理这一次触摸:  </p>
<ul>
<li>如果返回<code>true</code>, 则<code>CCTouchDispatcher</code>会根据用户的touch动作, 在后续调用本组件的<code>ccTouchMoved</code>, <code>ccTouchEnded</code>, <code>ccTouchCancelled</code>方法.</li>
<li>如果返回<code>false</code>, 则表示当前组件不处理此次touch事件. 后续的三个方法不会被调用.</li>
</ul>
<h3 id="CCScrollView-ccTouchBegan-解析"><a href="#CCScrollView-ccTouchBegan-解析" class="headerlink" title="CCScrollView::ccTouchBegan()解析"></a>CCScrollView::ccTouchBegan()解析</h3><p>无码无真相, 先贴一张代码图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bool CCScrollView::ccTouchBegan(CCTouch* touch, CCEvent* event)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;tag-1</span><br><span class="line">    if (!this-&gt;isVisible())</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;tag-2</span><br><span class="line">    CCRect frame &#x3D; getViewRect();</span><br><span class="line">    &#x2F;&#x2F;dispatcher does not know about clipping. reject touches outside visible bounds.</span><br><span class="line">    if (m_pTouches-&gt;count() &gt; 2 ||</span><br><span class="line">        m_bTouchMoved          ||</span><br><span class="line">        !frame.containsPoint(m_pContainer-&gt;convertToWorldSpace(m_pContainer-&gt;convertTouchToNodeSpace(touch))))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;tag-3</span><br><span class="line">    if (m_pTouches-&gt;count() &#x3D;&#x3D; 1)</span><br><span class="line">    &#123; &#x2F;&#x2F; scrolling</span><br><span class="line">        m_tTouchPoint     &#x3D; this-&gt;convertTouchToNodeSpace(touch);</span><br><span class="line">        m_bTouchMoved     &#x3D; false;</span><br><span class="line">        m_bDragging     &#x3D; true; &#x2F;&#x2F;dragging started</span><br><span class="line">        m_tScrollDistance &#x3D; ccp(0.0f, 0.0f);</span><br><span class="line">        m_fTouchLength    &#x3D; 0.0f;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;tag-4</span><br><span class="line">    else if (m_pTouches-&gt;count() &#x3D;&#x3D; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        m_bDragging  &#x3D; false;</span><br><span class="line">    &#125; </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把跟本博文主题关系不大的代码用省略号(…)代替了. 下面是相关代码解释:  </p>
<ul>
<li>tag-1 当此组件隐藏的时候, 不予处理.</li>
<li>tag-2 当此触摸点数大于2或者触摸点不在当前组件的显示范围内的时候, 不予处理.</li>
<li>tag-3 这是我们的重点. 当触摸点数等于1的时候, 处理滑动操作. </li>
<li>tag-4 触摸点等于2的时候, 响应缩放处理.</li>
</ul>
<h2 id="源代码的修改"><a href="#源代码的修改" class="headerlink" title="源代码的修改"></a>源代码的修改</h2><h3 id="变量申明及方法增加"><a href="#变量申明及方法增加" class="headerlink" title="变量申明及方法增加"></a>变量申明及方法增加</h3><p>在<code>CCScrollView.h</code>文件中增加以下成员变量和方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;CCScrollView.h</span><br><span class="line">public:</span><br><span class="line">	bool isPaged()&#123; return m_bPaged; &#125;;</span><br><span class="line">	void setPaged( bool value )&#123; m_bPaged &#x3D; value; &#125;;</span><br><span class="line">protected:</span><br><span class="line">    clock_t m_touchBeganTime;</span><br><span class="line">	int     m_touchBeganOffset;</span><br><span class="line">	int     m_targetPage;</span><br><span class="line">	int     m_currPage;</span><br><span class="line">	float   m_pageAccSpeed;</span><br><span class="line">	float   m_distanceRatioOfTurn;</span><br><span class="line">	bool    m_bPaged;</span><br><span class="line">	</span><br><span class="line">	void __pageTouchBegan();    &#x2F;&#x2F;在CCScrollView的滑动被触发的时候调用</span><br><span class="line">	bool __pageTouchEnd();      &#x2F;&#x2F;在ScrollView的滑动停止的时候调用</span><br><span class="line">	void __pageTouchCancel();   &#x2F;&#x2F;在滑动被取消的时候调用</span><br><span class="line">	void __pageClearTouch();    &#x2F;&#x2F;在一次滑动结束的时候调用</span><br></pre></td></tr></table></figure>

<h3 id="方法的实现"><a href="#方法的实现" class="headerlink" title="方法的实现:"></a>方法的实现:</h3><p>四个方法的代码可能要占用一些篇幅, 所以在这里, 先简要讲一下原理:</p>
<ol>
<li>在touch开始的时候, 记录一下当时时间<code>m_touchBeganTime</code>和开始滑动的位置<code>m_touchBeganOffset</code>.</li>
<li>在touch结束的时候, 获取结束时刻的时间和位置. 我们有两个标准来判断应该翻页还是停留在上一页:<ul>
<li>如果滑动距离超过一页距离的一半(或者是其他阈值),那么判断为用户希望翻到下一页(或上一页)</li>
<li>如果滑动速度超过一个阈值, 那么判断为用户希望翻到下一页(或上一页)  </li>
</ul>
</li>
<li>当做了判断之后, 即可滑动到对应的位置.</li>
</ol>
<p>下面是四个方法的实现, 实现了上述原理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">void CCScrollView::__pageTouchBegan()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;仅在设置了分页属性, 并且只有一个滑动方向的时候, 才支持分页.</span><br><span class="line">	if( !m_bPaged || ( m_eDirection !&#x3D; kCCScrollViewDirectionHorizontal &amp;&amp; m_eDirection !&#x3D; kCCScrollViewDirectionVertical )) return ;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;记录初试时间和位置</span><br><span class="line">	m_touchBeganTime &#x3D; clock();</span><br><span class="line">	m_touchBeganOffset &#x3D; m_eDirection &#x3D;&#x3D; kCCScrollViewDirectionHorizontal ? getContentOffset().x : getContentOffset().y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool CCScrollView::__pageTouchEnd()</span><br><span class="line">&#123;</span><br><span class="line">	if( !m_bPaged || ( m_eDirection !&#x3D; kCCScrollViewDirectionHorizontal &amp;&amp; m_eDirection !&#x3D; kCCScrollViewDirectionVertical )) return false ;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;constant</span><br><span class="line">	const float PAGE_DISTENCE &#x3D; m_eDirection &#x3D;&#x3D; kCCScrollViewDirectionHorizontal ? getViewSize().width : getViewSize().height ;</span><br><span class="line">	if( PAGE_DISTENCE &lt;&#x3D; 0 ) return false;</span><br><span class="line"></span><br><span class="line">	const float MAX_PAGE &#x3D; ( m_eDirection &#x3D;&#x3D; kCCScrollViewDirectionHorizontal ? getContentSize().width : getContentSize().height ) &#x2F; PAGE_DISTENCE;</span><br><span class="line">	const float MIN_PAGE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	float currOffset &#x3D; m_eDirection &#x3D;&#x3D; kCCScrollViewDirectionHorizontal ? getContentOffset().x : getContentOffset().y;</span><br><span class="line">	float deltaOffset &#x3D; -(currOffset - m_touchBeganOffset);</span><br><span class="line">	clock_t currTime &#x3D; clock();</span><br><span class="line">	float speed &#x3D;  currTime !&#x3D; m_touchBeganTime ? deltaOffset &#x2F; ( currTime - m_touchBeganTime ) : 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	m_targetPage &#x3D; m_currPage;</span><br><span class="line">	if( abs(deltaOffset) &gt;&#x3D; TURN_PAGE_MIN_OFFSET_RATIO*PAGE_DISTENCE )</span><br><span class="line">	&#123;&#x2F;&#x2F;滑动距离大于某一阈值.</span><br><span class="line">		</span><br><span class="line">		if( deltaOffset &gt; 0 )</span><br><span class="line">		&#123;</span><br><span class="line">			m_targetPage &#x3D; m_currPage + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if( deltaOffset &lt; 0 )</span><br><span class="line">		&#123;</span><br><span class="line">			m_targetPage &#x3D; m_currPage - 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if( abs(speed) &gt;&#x3D; TURN_PAGE_SPEED )</span><br><span class="line">	&#123;&#x2F;&#x2F;速度大于某一阈值.</span><br><span class="line">		if( speed &gt; 0 )</span><br><span class="line">		&#123;</span><br><span class="line">			m_targetPage &#x3D; m_currPage + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if( speed &lt; 0 )</span><br><span class="line">		&#123;</span><br><span class="line">			m_targetPage &#x3D; m_currPage - 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if( m_targetPage &gt; MAX_PAGE ) m_targetPage &#x3D; MAX_PAGE;</span><br><span class="line">	else if( m_targetPage &lt; MIN_PAGE ) m_targetPage &#x3D; MIN_PAGE;</span><br><span class="line"></span><br><span class="line">	float targetOffset &#x3D; -m_targetPage*( m_eDirection &#x3D;&#x3D; kCCScrollViewDirectionHorizontal ? getViewSize().width : getViewSize().height );</span><br><span class="line">	float pageDurateion &#x3D; 0.5;</span><br><span class="line">	CCPoint targetPointOffset &#x3D; m_eDirection &#x3D;&#x3D; kCCScrollViewDirectionHorizontal ? ccp( targetOffset, getContentOffset().y ) : ccp(getContentOffset().x, targetOffset );</span><br><span class="line">	setContentOffsetInDuration(targetPointOffset, pageDurateion);</span><br><span class="line"></span><br><span class="line">	m_currPage &#x3D; m_targetPage;</span><br><span class="line">	</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">void CCScrollView::__pageTouchCancel()</span><br><span class="line">&#123;</span><br><span class="line">	if( !m_bPaged || ( m_eDirection !&#x3D; kCCScrollViewDirectionHorizontal &amp;&amp; m_eDirection !&#x3D; kCCScrollViewDirectionVertical )) return ;</span><br><span class="line"></span><br><span class="line">	__pageClearTouch();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void CCScrollView::__pageClearTouch()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;clear所有状态</span><br><span class="line">	m_touchBeganOffset &#x3D; 0;</span><br><span class="line">	m_touchBeganTime &#x3D; 0;</span><br><span class="line">	m_targetPage &#x3D; m_currPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="修改后的CCScrollView-h-CCScrollView-cpp"><a href="#修改后的CCScrollView-h-CCScrollView-cpp" class="headerlink" title="修改后的CCScrollView.h, CCScrollView.cpp"></a>修改后的CCScrollView.h, CCScrollView.cpp</h2><p>这里是修改后的文件, 可以直接下载覆盖.<br><a href="http://pan.baidu.com/..." target="_blank" rel="noopener">CCScrollView.zip</a><br><strong><em>注意</em></strong>:上述代码仅在<code>cocos2dx-2.2.2</code>和<code>cocos2dx-2.2.1</code>版本上验证通过. 其他版本请根据上述原理做适当的修改<del>~</del></p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2014/03/23/%E6%8A%80%E6%9C%AF/[cocos2dx]%E8%AE%A9UIButton%E6%94%AF%E6%8C%81disable%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2014/03/23/%E6%8A%80%E6%9C%AF/%5Bcocos2dx%5D%E8%AE%A9UIButton%E6%94%AF%E6%8C%81disable%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">[cocos2dx]让UIButton支持disable状态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-03-23 22:16:00" itemprop="dateCreated datePublished" datetime="2014-03-23T22:16:00+08:00">2014-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          在cocostudio中添加一个UIButton组件, 我们可以看到通常以一下按钮的三态:normal,pressed,disable. 但是,当我们设置了disable状态之后, 在我们的游戏项目中, 对某个按钮执行button->setEnable(false)后, 按钮居然完全不见了?!
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2014/03/23/%E6%8A%80%E6%9C%AF/%5Bcocos2dx%5D%E8%AE%A9UIButton%E6%94%AF%E6%8C%81disable%E7%8A%B6%E6%80%81/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/12/31/%E6%8A%80%E6%9C%AF/[iOS]%E6%98%AF%E6%80%8E%E4%B9%88%E3%80%8C%E7%BB%98%E7%94%BB%E3%80%8D%E7%9A%84?/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/12/31/%E6%8A%80%E6%9C%AF/%5BiOS%5D%E6%98%AF%E6%80%8E%E4%B9%88%E3%80%8C%E7%BB%98%E7%94%BB%E3%80%8D%E7%9A%84?/" class="post-title-link" itemprop="url">[iOS]是怎么「绘画」的?</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2013-12-31T00:00:00+08:00">2013-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>摘要：如果您以前从事其它平台的图形/界面开发或者游戏开发,一定知道, 不管上层UI怎么呈现和响应, 底层必须有一个绘图引擎. iOS也不例外. 本文详细介绍了iOS Graphics的用法和相关知识, 希望对您的Coding有帮助.  </p>
<p>^此博客需要对<code>CALayer</code>和<code>UIView</code>有基本的了解. 可参考博客<a href="http://geeklu.com/2012/09/animation-in-ios/" target="_blank" rel="noopener">谈谈iOS Animation</a></p>
<h1 id="什么是绘图引擎"><a href="#什么是绘图引擎" class="headerlink" title="什么是绘图引擎"></a>什么是绘图引擎</h1><p>绘图引擎, 通俗来说就好比给你一张纸一支笔和若干颜色的颜料, 你可以用它来做<strong>最基本</strong>的图形绘制.<br>一个<strong>最基本的绘图引擎</strong>包括一下接口:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code-1</span></span><br><span class="line">I1. drawLine()		<span class="comment">//绘制任意线条,并支持对线条上色.</span></span><br><span class="line">I2. drawPath()		<span class="comment">//根据路径绘制形状,并支持填充颜色.</span></span><br><span class="line">I3. drawImage()		<span class="comment">//绘制图像(e.g. xxx.jpg, xxx.png)</span></span><br><span class="line">I4. drawGradient()	<span class="comment">//绘制渐变填充</span></span><br><span class="line">I5. transform()		<span class="comment">//矩阵映射变换.</span></span><br><span class="line">I6. drawText()		<span class="comment">//绘制文字</span></span><br></pre></td></tr></table></figure>

<p>不难想象, 有了以上接口, 我们就可以<strong>方便</strong>的绘制任意想要的图像.<br>这里强调的是<strong>方便</strong>, 有些接口并不是<strong>必须</strong>的. 比如说<code>drawImage()</code>,我们总可以调用有限次<code>drawLine()</code>和<code>drawShape()</code>来绘制任意给定的Image. 但是复杂程度可想而知.<br>一个绘图引擎设计的目的就是为了方便上层调用, 所以它会封装一些<strong>最常用</strong>和<strong>最基本</strong>的接口. 以上5个接口就满足这两个条件之一. 所谓<strong>最常用</strong>和<strong>最基本</strong>并没有一个明确的定义, 所以不同的绘图引擎可能会多一些常用接口,但都大同小异.</p>
<br/>
<br/>
<br/>
# iOS的绘图引擎
下面我们就`Code-1`里提到的接口在iOS平台上做一个介绍.

<h2 id="在哪里绘制"><a href="#在哪里绘制" class="headerlink" title="在哪里绘制?"></a>在哪里绘制?</h2><p>如果我们在XCode里新建一个<code>UIView</code>类, 我们会得到以下代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code-2</span></span><br><span class="line"><span class="meta"># import <span class="meta-string">"GraphicsViewControllerView.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GraphicsViewControllerView</span></span></span><br><span class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]; </span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="comment">// Initialization code &#125;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Drawing code </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>通常,<code>drawRect()</code>都会被注释起来. 因为, 如果你向<code>UIView</code>添加<code>subView</code>或者设置<code>UIView</code>的显示相关的属性(e.g. <code>backgroundCrolor</code>)的时候, <code>UIKit</code>会自动的把这些参数代表的含义绘制到<code>CALayer</code>上去. 也就是说, 一般情况我们并不需要自己来绘制, <code>UIKit</code>会自动帮我们完成绘制工作.<br>但是, 当不添加<code>subView</code>, 不设置<code>UIView</code>的显示相关的属性时, 我们就可以通过重载<code>drawRect()</code>来手动绘制图像了.   </p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote>
<p>A graphical context can be thought of as a canvas, offering an enormous number of properties such as pen color, pen thickness, etc. Given the context, you can start painting straight away inside the drawRect: method, and Cocoa Touch will make sure that the attributes and properties of the context are applied to your drawings. We will talk about this more later, but now, let’s move on to more interesting subjects.</p>
</blockquote>
<h2 id="drawText"><a href="#drawText" class="headerlink" title="drawText"></a>drawText</h2><p>我们新建一个<code>UIView</code>类<code>CustomUIView</code>,如下重载<code>drawRect()</code>方法.<br>新建<code>CustomUIView</code>的对象,不设置任何属性,添加到显示列表. </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code-3</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123; </span><br><span class="line">	<span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontWithSize:<span class="number">40.</span>f]; </span><br><span class="line">	<span class="built_in">NSString</span> *myString = <span class="string">@"Some String"</span>;</span><br><span class="line">	[myString drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">40</span>, <span class="number">180</span>) withFont:font];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行, 就可以看到我们没有添加任何<code>UITextField</code>却显示了文字~  </p>
<h4 id="more"><a href="#more" class="headerlink" title="more:"></a>more:</h4><p>关于文字绘制的方法还有 <code>drawInRect:withFont:</code>等几个方法, 可参考官方文档.</p>
<h2 id="setColor"><a href="#setColor" class="headerlink" title="setColor"></a>setColor</h2><p>我们把<code>Code-3</code>中的代码添加两行, 变成:  </p>
<figure class="highlight objc"><figcaption><span>code-4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code-4</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123; </span><br><span class="line">	<span class="built_in">UIColor</span>* color = [<span class="built_in">UIColor</span> blueColor];		<span class="comment">//create color</span></span><br><span class="line">	[color set];								<span class="comment">//set color</span></span><br><span class="line">	<span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontWithSize:<span class="number">40.</span>f]; </span><br><span class="line">	<span class="built_in">NSString</span> *myString = <span class="string">@"Some String"</span>;</span><br><span class="line">	[myString drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">40</span>, <span class="number">180</span>) withFont:font];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以看到,文字由黑色变成了蓝色.  </p>
<h4 id="more-1"><a href="#more-1" class="headerlink" title="more:"></a>more:</h4><p><code>UIColor</code>还有两个方法<code>setStroke</code>和<code>setFill</code>分别设置线条颜色和填充颜色. 在后面的章节会用到.<code>set</code>方法影响所有前景色.</p>
<h2 id="drawImage"><a href="#drawImage" class="headerlink" title="drawImage"></a>drawImage</h2><p>同样的, 如下重写<code>drawRect</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code-5</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123; </span><br><span class="line">	<span class="comment">/* Assuming the image is in your app bundle and we can load it */</span></span><br><span class="line">	<span class="built_in">UIImage</span> *xcodeIcon = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"filename.png"</span>];</span><br><span class="line">	[xcodeIcon drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0.0</span>f, <span class="number">20.0</span>f)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到图像被绘制出来了.</p>
<h4 id="more-2"><a href="#more-2" class="headerlink" title="more:"></a>more:</h4><p><code>UIImage</code>还有其他绘制方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drawInRect:</span><br><span class="line">drawAsPatternInRect:</span><br><span class="line">drawAtPoint:blendMode:alpha:</span><br><span class="line">drawInRect:blendMode:alpha:</span><br></pre></td></tr></table></figure>

<p>方法名已经很清楚的说明了方法的用途. 具体可参考官方文档</p>
<h2 id="drawLine"><a href="#drawLine" class="headerlink" title="drawLine"></a>drawLine</h2><p>这两个是绘图引擎里最基本的, 所以放在一起讲述.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Code-6: drawLine</span><br><span class="line">- (void)drawRect:(CGRect)rect&#123; </span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step1 设置绘图颜色 *&#x2F; </span><br><span class="line">	[[UIColor brownColor] set];</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step2 获取当期的画布: Graphic Context *&#x2F; </span><br><span class="line">	CGContextRef currentContext &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step3 设置线条宽度 *&#x2F; </span><br><span class="line">	CGContextSetLineWidth(currentContext,5.0f);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step4 把画笔移动到起始点 *&#x2F; </span><br><span class="line">	CGContextMoveToPoint(currentContext,50.0f, 10.0f);</span><br><span class="line">	&#x2F;* Step5 从起始点绘制线条到终点 *&#x2F; </span><br><span class="line">	CGContextAddLineToPoint(currentContext,100.0f, 200.0f);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step6 提交绘制 *&#x2F;</span><br><span class="line">	CGContextStrokePath(currentContext); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想连续绘制多条线, 可以再<code>Code-6</code>中的<code>Step5</code>和<code>Step6</code>之间多次调用<code>CGContextAddLineToPoint()</code>.</p>
<h4 id="more-3"><a href="#more-3" class="headerlink" title="more:"></a>more:</h4><p><code>CGContextSetLineJoin</code>可以改变线条交叉点的样式.</p>
<h2 id="drawPath"><a href="#drawPath" class="headerlink" title="drawPath"></a>drawPath</h2><p>如果我们想快速绘制一条折线, 调用<code>drawLine</code>就显得有些臃肿. 所以有了<code>drawPath</code>, 它是<code>drawLine</code>的加强版.<br><code>drawPath</code>的一般步骤如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Code-7: drawPath</span><br><span class="line">- (void)drawRect:(CGRect)rect&#123; </span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step1 获取当期的画布: Graphic Context *&#x2F; </span><br><span class="line">	CGContextRef currentContext &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step2 创建 path *&#x2F; </span><br><span class="line">	CGMutablePathRef path &#x3D; CGPathCreateMutable();</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step3 移动到起始点 *&#x2F;</span><br><span class="line">	CGPathMoveToPoint(path,NULL, screenBounds.size.width, screenBounds.origin.y);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step4 绘制一个椭圆 *&#x2F;</span><br><span class="line">	CGPathAddEllipseInRect(path, &amp;CGAffineTransformIdentity, CGRectMake(0, 320, 320, 160));</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step5 再添加一条直线 *&#x2F;</span><br><span class="line">	CGPathAddLineToPoint(path,NULL, screenBounds.origin.x, screenBounds.size.height);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step6 向画布添加path *&#x2F;</span><br><span class="line">	CGContextAddPath(currentcontext, path);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step7 设置绘制类型: kCGPathStroke(绘制边缘), kCGPathFill(填充path内区域), kCGPathFillStroke(包含前面两项)*&#x2F;</span><br><span class="line">	CGContextDrawPath(currentcontext, kCGPathFillStroke);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step8 提交绘制 *&#x2F;</span><br><span class="line">	CGContextStrokePath(currentContext); </span><br><span class="line">	</span><br><span class="line">	&#x2F;* Step9 release path *&#x2F;</span><br><span class="line">	CGPathRelease(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="more-4"><a href="#more-4" class="headerlink" title="more:"></a>more:</h4><p>常见几何图形的绘制接口: <code>CGPathAddCurveToPoint</code>,<code>CGPathAddArcToPoint</code>,<code>CGPathAddRect</code>等等…</p>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>iOS中的<code>transform</code>使用<code>CGAffineTransform</code>表示的. 你可以用矩阵方式构造任意二维变换:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">a: The value at position [1,1] in the matrix.</span><br><span class="line">b: The value at position [1,2] in the matrix.</span><br><span class="line">c: The value at position [2,1] in the matrix.</span><br><span class="line">d: The value at position [2,2] in the matrix.</span><br><span class="line">tx: The value at position [3,1] in the matrix.</span><br><span class="line">ty: The value at position [3,2] in the matrix.</span><br><span class="line">*&#x2F;</span><br><span class="line">CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty)</span><br></pre></td></tr></table></figure>
<p>矩阵表示为:<br><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGAffineTransform/Art/equation01_2x.png" alt=""></p>
<p>iOS也提供了常见变换的快速构建方式:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGAffineTransformIdentity			&#x2F;&#x2F;单位矩阵, 不做任何变换</span><br><span class="line">CGAffineTransformMakeRotation		&#x2F;&#x2F;旋转</span><br><span class="line">CGAffineTransformMakeScale			&#x2F;&#x2F;缩放</span><br><span class="line">CGAffineTransformMakeTranslation	&#x2F;&#x2F;平移</span><br></pre></td></tr></table></figure>

<p>在<code>Code-7 Step4</code>中, 绘制<code>path</code>时用到了单位矩阵<code>CGAffineTransformIdentity</code>, 表示不做任何变换. 通常情况下, 都是在绘制阶段把<code>transform</code>作为参数传入. 上面提到的<code>CGPathAddCurveToPoint</code>,<code>CGPathAddArcToPoint</code>,<code>CGPathAddRect</code>函数都有一个<code>transform</code>参数.</p>
<br/>
<br/>
<br/>
# iOS绘图在项目中的应用
通常, 我们只需要随心所欲的对`UIView`增加`subView`, `UIKit`会自动帮我们绘制. 但是下列情况下可能需要手动绘制:  

<ol>
<li>优化<code>UITableViewCell</code>的时候. 如果我们的<code>cell</code>很复杂, 有很多<code>subView</code>, 就会变得很卡顿. 就需要手动绘制了. 可参考博客: <a href="http://www.keakon.net/2011/08/03/%E4%BC%98%E5%8C%96UITableView%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">优化UITableView性能</a>或者<a href="http://blog.csdn.net/cocoarannie/article/details/11183067" target="_blank" rel="noopener">IOS详解TableView——性能优化及手工绘制UITableViewCell</a></li>
<li>暂未想到, 以后想到再说.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/12/19/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-2013/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/12/19/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-2013/" class="post-title-link" itemprop="url">[设计模式]结构型模式-2013</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-12-19 00:00:00" itemprop="dateCreated datePublished" datetime="2013-12-19T00:00:00+08:00">2013-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter(适配器)"></a>Adapter(适配器)</h2><p>在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。<br>有两类适配器模式：</p>
<ul>
<li>对象适配器模式 - 在这种适配器模式中，适配器容纳一个它我包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</li>
<li>类适配器模式 - 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</li>
</ul>
<h2 id="Bridge-桥接"><a href="#Bridge-桥接" class="headerlink" title="Bridge(桥接)"></a>Bridge(桥接)</h2><p>在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。</p>
<h3 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h3><p><img src="" alt=""><br><img src="" alt=""></p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>比如一个动物<code>IAnimal</code>, 有移动,呼吸,吃东西,繁殖四种行为.我们把这几种行为都抽象出来, 变成<code>IMovable,IBreathable,IEatable,IBreedable</code>. 上面的四个接口, 每个接口都有若干种实现方式, 比如<code>IMovable</code>有<code>Swamable</code>,<code>Runnable</code>,<code>Fliable</code>三种实现方式. 这样, 我们<strong>定义</strong>或者说<strong>添加</strong>一种新动物<code>AnimalNew</code>的时候, 只需把对应的行为方式组装到<code>AnimalNew</code>中即可.</p>
<p>深刻体会过的例子是游戏的<strong>背包系统</strong>. 背包中每个物品有交易(买卖),穿戴(佩戴),损耗(随着某个变量而效果减少),作用(属性加成),生成tips…等行为</p>
<h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><p>如果一个实体类的某个行为有多种实现方式, 我们一般用继承来协调他们. 假设一个实体类的有n种行为. 每种行为有f(n)种实现方式, 那么我们继承的代价就是n*f(n)。继承机制将抽象部分与他的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和充用。<br>如果用桥接模式,把每种行为都抽象出来,则会更加灵活.  </p>
<p>其实我觉得Bridge的本质就是把该抽象的都抽象出来,每个接口只表示一种行为. </p>
<p>参考博客:</p>
<ul>
<li><a href="http://www.cnblogs.com/houleixx/archive/2008/02/23/1078877.html" target="_blank" rel="noopener">设计模式—–桥接模式(Bridge Pattern)</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7529194" target="_blank" rel="noopener">设计模式（六）桥连模式Bridge（结构型）</a></li>
</ul>
<p>##</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/12/12/%E6%8A%80%E6%9C%AF/[iOS]Orientation%20%E6%83%B3%E6%80%8E%E4%B9%88%E8%BD%AC%E5%B0%B1%E6%80%8E%E4%B9%88%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/12/12/%E6%8A%80%E6%9C%AF/%5BiOS%5DOrientation%20%E6%83%B3%E6%80%8E%E4%B9%88%E8%BD%AC%E5%B0%B1%E6%80%8E%E4%B9%88%E8%BD%AC/" class="post-title-link" itemprop="url">[iOS]Orientation 想怎么转就怎么转</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-12-12 00:00:00" itemprop="dateCreated datePublished" datetime="2013-12-12T00:00:00+08:00">2013-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>此博文主要针对IOS应用, 是屏幕旋转相关问题的一个总结. 主要内容有:  </p>
<ol>
<li>IOS5,6,7不同版的适配.  </li>
<li>强制旋转和自动旋转.</li>
</ol>
<hr>
<h2 id="改变Orientation的三种途径"><a href="#改变Orientation的三种途径" class="headerlink" title="改变Orientation的三种途径"></a>改变Orientation的三种途径</h2><p>这里, 咱们主要理清一下: <strong>到底有哪些设置可以改变屏幕旋转特性</strong>. 这样:  </p>
<ul>
<li>出现任何问题我们都可以从这几个途径中发现原因.</li>
<li>灵活应付产品经理的各种需求.  </li>
</ul>
<p>首先我们得知道: </p>
<ol>
<li>当手机的重力感应打开的时候, 如果用户旋转手机, 系统会抛发<code>UIDeviceOrientationDidChangeNotification</code> 事件.  </li>
<li>您可以分别设置<code>Application</code>和<code>UIViewcontroller</code>支持的旋转方向.<code>Application</code>的设置会影响整个App, <code>UIViewcontroller</code>的设置仅仅会影响一个<code>viewController</code>(IOS5和IOS6有所不同,下面会详细解释).  </li>
<li>当<code>UIKit</code>收到<code>UIDeviceOrientationDidChangeNotification</code>事件的时候, 会根据<code>Application</code>和<code>UIViewcontroller</code>的设置, 如果双方都支持此方向, 则会自动屏幕旋转到这个方向. 更code的表达就是, 会对两个设置求<strong>与</strong>,得到可以支持的方向. 如果求<strong>与</strong>之后,没有任何可支持的方向, 则会抛发<code>UIApplicationInvalidInterfaceOrientationException</code>异常.</li>
</ol>
<br/>
<br/>
<br/>
### Info.plist设置
在App的Info.plist里设置:

<table>
<thead>
<tr>
<th align="left">key</th>
<th align="left">xcode name</th>
<th align="left">Summary</th>
<th align="left">avilable value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UIInterfaceOrientation</td>
<td align="left">initial interface orientation</td>
<td align="left">Specifies the initial orientation of the app’s user interface.</td>
<td align="left">UIInterfaceOrientationPortrait,<br/>UIInterfaceOrientationPortraitUpsideDown,<br/>UIInterfaceOrientationLandscapeLeft,<br/>UIInterfaceOrientationLandscapeRight</td>
</tr>
<tr>
<td align="left">UISupportedInterfaceOrientations</td>
<td align="left">Supported interface orientations</td>
<td align="left">Specifies the orientations that the app supports.</td>
<td align="left">UIInterfaceOrientationPortrait,<br/>UIInterfaceOrientationPortraitUpsideDown,<br/>UIInterfaceOrientationLandscapeLeft,<br/>UIInterfaceOrientationLandscapeRight</td>
</tr>
</tbody></table>
<p>在Info.plist中设置之后,这个app里所有的<code>viewController</code>支持的自动旋转方向都只能是app支持的方向的子集.</p>
<br/>
<br/>
<br/>
### UIViewController
#### IOS6 and above
##### supportedInterfaceOrientations

<p>在IOS6及以上的版本中, 增添了方法<code>UIViewController.supportedInterfaceOrientations</code>. 此方法返回当前<code>viewController</code>支持的方向. 但是, 只有两种情况下此方法才会生效:</p>
<ol>
<li>当前<code>viewController</code>是<code>window</code>的<code>rootViewController</code>. </li>
<li>当前<code>viewController</code>是<code>modal</code>模式的. 即, 此<code>viewController</code>是被调用<code>presentModalViewController</code>而显示出来的.</li>
</ol>
<p>在以上两种情况中,<code>UIViewController.supportedInterfaceOrientations</code>方法会作用于当前<code>viewController</code>和所有<code>childViewController</code>. 以上两种情况之外, <code>UIKit</code>并不会理会你的<code>supportedInterfaceOrientations</code>方法.</p>
<p>举个栗子: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个<code>viewController</code>实现了以上方法. 则, 此<code>viewController</code>就支持竖方向和左旋转方向. 此<code>viewController</code>的所有<code>childViewController</code>也同时支持这两个方向, 不多不少. </p>
<h5 id="preferredInterfaceOrientationForPresentation"><a href="#preferredInterfaceOrientationForPresentation" class="headerlink" title="preferredInterfaceOrientationForPresentation"></a>preferredInterfaceOrientationForPresentation</h5><p>此方法也属于<code>UIViewController</code>. 影响当前<code>viewController</code>的初始显示方向.<br>此方法也仅有在当前<code>viewController</code>是<code>rootViewController</code>或者是<code>modal</code>模式时才生效.</p>
<h5 id="shouldAutorotate"><a href="#shouldAutorotate" class="headerlink" title="shouldAutorotate"></a>shouldAutorotate</h5><p>此方法,用于设置当前<code>viewController</code>是否支持自动旋转. 如果,你需要<code>viewController</code>暂停自动旋转一小会儿. 那么可以通过这个方法来实现.同样的, 此方法也仅有在当前<code>viewController</code>是<code>rootViewController</code>或者是<code>modal</code>模式时才生效.  </p>
<h4 id="IOS5-and-before"><a href="#IOS5-and-before" class="headerlink" title="IOS5 and before"></a>IOS5 and before</h4><p>在IOS5和以前的版本中, 每个<code>viewController</code>都可以指定自己可自动旋转的方向.(<del>这样不是挺好么?苹果那帮工程师为啥要搞成这样…</del>).<br>每当<code>UIkit</code>收到<code>UIDeviceOrientationDidChangeNotification</code>消息的时候, 就会用以下方法询问当前显示的<code>viewController</code>支不支持此方向:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)orientation</span><br><span class="line">&#123;</span><br><span class="line">   if ((orientation &#x3D;&#x3D; UIInterfaceOrientationPortrait) ||</span><br><span class="line">       (orientation &#x3D;&#x3D; UIInterfaceOrientationLandscapeLeft))</span><br><span class="line">      return YES;</span><br><span class="line"> </span><br><span class="line">   return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别要注意的是:你必须至少要对一个方向返回<code>YES</code>.(为难系统总不会有啥好事儿,你懂得).</p>
<br/>
<br/>
<br/>
### UIView.transform
最后一个方法是设置`UIView`的`transform`属性来强制旋转.   
见下代码: 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置statusBar</span><br><span class="line">[[UIApplication sharedApplication] setStatusBarOrientation:orientation];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算旋转角度</span><br><span class="line">float arch;</span><br><span class="line">if (orientation &#x3D;&#x3D; UIInterfaceOrientationLandscapeLeft)</span><br><span class="line">	arch &#x3D; -M_PI_2;</span><br><span class="line">else if (orientation &#x3D;&#x3D; UIInterfaceOrientationLandscapeRight)</span><br><span class="line">	arch &#x3D; M_PI_2;</span><br><span class="line">else</span><br><span class="line">	arch &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对navigationController.view 进行强制旋转</span><br><span class="line">self.navigationController.view.transform &#x3D; CGAffineTransformMakeRotation(arch);</span><br><span class="line">self.navigationController.view.bounds &#x3D; UIInterfaceOrientationIsLandscape(orientation) ? CGRectMake(0, 0, SCREEN_HEIGHT, SCREEN_WIDTH) : initialBounds;</span><br></pre></td></tr></table></figure>
<p>需要注意的是: </p>
<ol>
<li>当然我们可以对当前<code>viewController</code>进行旋转, 对任何<code>view</code>旋转都可以.但是, 你会发现<code>navigationBar</code>还横在那里. 所以, 我们最好对一个占满全屏的<code>view</code>进行旋转. 在这里我们旋转的对象是<code>self.navigationController.view</code>, 当然<code>self.window</code>也可以, help yourself~</li>
<li>我们需要显式的设置<code>bounds</code>. <code>UIKit</code>并不知道你偷偷摸摸干了这些事情, 所以没法帮你自动设置.</li>
</ol>
<br/>
<br/>
## 如何应付产品经理的需求
有了以上三把武器, 我想基本可以应付BT产品经理所有的需求了. 但是这里还有一些小技巧.
### 直接锁死
(略)
### 随系统旋转
#### IOS5及之前
对于IOS5及之前的版本, 只要在对每个`viewController`重写`shouldAutorotateToInterfaceOrientation`方法, 即可方便的控制每个`viewController`的方向.  

<h4 id="IOS6及以后"><a href="#IOS6及以后" class="headerlink" title="IOS6及以后"></a>IOS6及以后</h4><p>对于IOS6及以后的版本, 如果想方便的单独控制每个<code>viewController</code>的方向. 则可以使用这样:</p>
<ul>
<li><p>对于非<code>modal</code>模式的<code>viewController</code>: </p>
<ul>
<li>如果不是<code>rootViewController</code>,则重写<code>supportedInterfaceOrientations</code>,<code>preferredInterfaceOrientationForPresentation</code>以及<code>shouldAutorotate</code>方法, 按照当前<code>viewController</code>的需要返回响应的值.</li>
<li>如果是<code>rootViewController</code>,则如下重写方法:</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(NSUInteger)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">	return self.topMostViewController.supportedInterfaceOrientations;</span><br><span class="line">&#125;</span><br><span class="line">-(BOOL)shouldAutorotate</span><br><span class="line">&#123;</span><br><span class="line">    return [self.topMostViewController shouldAutorotate];</span><br><span class="line">&#125;</span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation</span><br><span class="line">&#123;</span><br><span class="line">    return [self.topMostViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br><span class="line">-(UIViewController*)topMostViewController</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;找到当前正在显示的viewController并返回.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见, 我们巧妙的绕开了<code>UIKit</code>只调用<code>rootViewController</code>的方法的规则. 把决定权交给了当前正在显示的<code>viewController</code>.    </p>
<ul>
<li>对于<code>modal</code>模式的<code>viewController</code>. 则按照需要重写<code>supportedInterfaceOrientations</code>,<code>preferredInterfaceOrientationForPresentation</code>以及<code>shouldAutorotate</code>方法即可.</li>
</ul>
<h3 id="强制旋转"><a href="#强制旋转" class="headerlink" title="强制旋转"></a>强制旋转</h3><p>有时候, 需要不随系统旋转, 而是强制旋转到某一个角度. 最典型的场景就是视频播放器, 当点击了全屏按钮的时候, 需要横过来显示.  </p>
<ul>
<li>对于IOS5及以前的版本, 可以用下面的方法:  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;</span><br><span class="line">	SEL selector &#x3D; NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class="line">	NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class="line">	[invocation setSelector:selector];</span><br><span class="line">	[invocation setTarget:[UIDevice currentDevice]];</span><br><span class="line">	int val &#x3D; UIInterfaceOrientationLandscapeRight;</span><br><span class="line">	[invocation setArgument:&amp;val atIndex:2];</span><br><span class="line">	[invocation invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于IOS6及以后的版本. <code>UIDevice.setOrientation</code>从隐藏变为移除.只能通过设置<code>UIView.transform</code>的方法来实现.</li>
</ul>
<br/>
<br/>
<br/>
## 参考资料

<ul>
<li><a href="http://blog.csdn.net/volcan1987/article/details/11563741" target="_blank" rel="noopener">iOS两个强制旋转屏幕的方法</a></li>
<li><a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/RespondingtoDeviceOrientationChanges/RespondingtoDeviceOrientationChanges.html" target="_blank" rel="noopener">Supporting Multiple Interface Orientations</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/11/10/%E6%8A%80%E6%9C%AF/[iOS]VoIP%E8%A7%A3%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/11/10/%E6%8A%80%E6%9C%AF/%5BiOS%5DVoIP%E8%A7%A3%E5%AF%86/" class="post-title-link" itemprop="url">[iOS]VoIP解密</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-11-10 00:00:00" itemprop="dateCreated datePublished" datetime="2013-11-10T00:00:00+08:00">2013-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>摘要：一般来说, IOS很少给App后台运行的权限. 仅有的方式就是 VoIP. IOS少有的为VoIP应用提供了<strong>后台socket连接,定期唤醒并且随开机启动</strong>的权限.而这些就是IOS上实现VoIP App的关键. 苹果官方文档对于的描述就短短的一页(<a href="https://developer.apple.com/library/ios/documentation/iphone/conceptual/iphoneosprogrammingguide/AdvancedAppTricks/AdvancedAppTricks.html#//apple_ref/doc/uid/TP40007072-CH7-SW12" target="_blank" rel="noopener">点击这里</a>),很多细节没有提及. 这篇微博通过具体实现和查阅资料,补充了这些细节.并且列举出了在实现过程中可能遇到的问题, 作为参考.</p>
<hr>
<h1 id="官方文档描述如是"><a href="#官方文档描述如是" class="headerlink" title="官方文档描述如是:"></a>官方文档描述如是:</h1><p><strong>PS:</strong>此节纯用来占座.如果你你E文不好或者想直接切入正题, 请看下一标题.  </p>
<blockquote>
<p>There are several requirements for implementing a VoIP app:</p>
</blockquote>
<blockquote>
<ol>
<li>Add the UIBackgroundModes key to your app’s Info.plist file. Set the value of this key to an array that includes the voip string.  </li>
</ol>
</blockquote>
<ol>
<li>Configure one of the app’s sockets for VoIP usage.<br>S</li>
<li>Before moving to the background, call the setKeepAliveTimeout:handler: method to install a handler to be executed periodically. Your app can use this handler to maintain its service connection.  </li>
<li>Configure your audio session to handle transitions to and from active use.  </li>
<li>To ensure a better user experience on iPhone, use the Core Telephony framework to adjust your behavior in relation to cell-based phone calls; see Core Telephony Framework Reference.  </li>
<li>To ensure good performance for your VoIP app, use the System Configuration framework to detect network changes and allow your app to sleep as much as possible.</li>
</ol>
<h1 id="我的翻译"><a href="#我的翻译" class="headerlink" title="我的翻译:"></a>我的翻译:</h1><p>关于IOS为VoIP应用提供的特殊权限和实现方法,我的描述如下. 我尽可能的涉及到voip实现的各种细节, 这样你能对这个运作机制有一个更好的<strong>理解</strong>,我觉得这远比单单贴几行代码有意义. 因为一个开发者在实际实现过程中遇到的千难险阻很少会体现在最终代码上, 就如你永远不知道台上的角儿在台下的挫折.  </p>
<ol>
<li><strong>IOS允许App的一个Socket在App切换到后台后仍然保持连接</strong>. 这样,当有通话请求的时候,App能及时处理. 这个<code>socket</code>需要在应用第一次启动的时候创建, 并标记为”此<code>socket</code>用于VoIP服务”. 这样当App切换到后台的时候,IOS会<strong>接管</strong>这个标记为”用于VoIP服务”的<code>socket</code>. 这个<code>socket</code>的响应函数(比如,一个<code>delegate</code>,或者是个<code>block</code>)会正常的响应, 就像App还在前台一样.  </li>
<li><strong>10s魔咒</strong>. 当<code>socket</code>有任何数据从服务端传来, 你在app里为<code>socket</code>写的响应函数都会做处理.但是, 你只有最多10s的时间来干你想干的事情. 也就意味着你在响应函数里新建一个大于10s的<code>timer</code>是没有意义的. 并且IOS并不保证给你足够10s的时间,视系统情况而定. </li>
<li>在<code>socket</code>的响应函数里, 你能通过<code>NSLocalNotification</code>来通知用户”电话来了”. 除此之外, 你没法做其他任何视觉上的动作来提醒用户, 因为你的app还处于某个不知道的次元, 甚至连<code>window</code>都还没创建. </li>
<li>你永远也没有办法知道或者决定<code>NSLocalNotification</code>的样式是<code>banner</code>还是<code>alert</code>. 你也许钟爱后者, 但是决定权在用户手里.</li>
<li><strong>允许在后台定期执行一段代码</strong>. 你可以设定一个大于等于10分钟的时间<code>t</code>, 和一个定期执行的<code>handler</code>, IOS系统会在每次经过<code>t</code>时间的时候调用一次这个<code>handler</code>. 但是IOS不保证这个<code>handler</code>会准时运行, 只保证在时间<code>t</code>范围内的某个点会执行一次.   </li>
<li>我们通常用楼上的<code>handler</code>处理socket的断线重连操作. 因为网络不稳定, 或者用户开启飞行模式等原因, 我们用于voip服务的<code>socket</code>会断开连接. 在这个<code>handler</code>里,如果发现连接断开,我们只需要跟条目1一样的创建<code>socket</code>,设置一样的<code>socket</code>响应函数,一切又会恢复正常.</li>
<li>不建议这个<code>handler</code>做太多事情, 因为它也有<strong>10s魔咒</strong>.(据不完全统计,苹果所有的后台处理都有这个10s限制. 不保证绝对正确哈, 仅供参考)</li>
<li><strong>自启服务</strong>. 当IOS重新启动, 或者你的app因为其他原因退出时, IOS会马上启动你注册为voip的app, 你可以很迅速的恢复<code>socket</code>连接. 但是, 从底部多任务栏中手动关闭应用除外.更”code”的说明是:当程序退出的<code>exitcode != 0</code>,IOS会重启你的app.经试验发现,从底部多任务栏关闭的时候,程序的<code>exitcode == 0</code>.</li>
<li>如果你亲爱的用户是一个典型的”app终结者”,那么你还剩最后一条路来通知来电提醒:<code>NSRemoteNotification</code>.  你也许会被<code>NSRemoteNotification</code>的可靠性和实时性折腾的抓狂, 但是, 谁让你选了IOS? 你享受了封闭带来的传世体验, 也得承受封闭的限制.  </li>
<li>当条目8描述的情况发生之后,app的<code>application:didFinishLaunchingWithOptions:</code>会被调用. 但是,请时刻提醒自己我们的app仍然处于后台. 我们以前总在这里创建<code>window</code>创建<code>rootController</code>, 但现在不必了. 现在我们需要的就是把可爱的<code>socket</code>连上, 像在条目1里一样,让一切回归正常(我不去写歌词真浪费了^_^).</li>
<li>在<code>application:didFinishLaunchingWithOptions:</code>里你能通过<code>[application applicationState] == UIApplicationStateBackground</code>来判断是正常启动应用还是系统自动启动, 然后决定该创建<code>window</code>还是创建voip的<code>socket</code>.</li>
<li>如果你看完上面一头雾水. 请回炉重造, 传送门:<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="noopener">Programming with Objective-C</a>, <a href="https://developer.apple.com/library/ios/navigation/" target="_blank" rel="noopener">iOS Develop Library</a>.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/11/03/%E6%8A%80%E6%9C%AF/[iOS]UIView%E4%BD%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%A4%A7%E6%8F%AD%E7%A7%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/11/03/%E6%8A%80%E6%9C%AF/%5BiOS%5DUIView%E4%BD%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%A4%A7%E6%8F%AD%E7%A7%98/" class="post-title-link" itemprop="url">[iOS]UIView.frame的骗局</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-11-03 00:25:00" itemprop="dateCreated datePublished" datetime="2013-11-03T00:25:00+08:00">2013-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>摘要：如果你刚刚开始接触IOS编程, 刚刚接触UIKit, 肯定会被 <code>frame, bounds, center, layer.anchorPoint, layer.position</code> 这些乱七八糟得属性折腾得心烦意乱. 并且,聪明的你肯定早就发现,这些属性并不是独立的, 比如<code>frame</code>和<code>bounds</code>, 你改变一个必然会影响另一个, 这就更加大了理解难度. 我想通过这篇<strong>浅显的日志,和一个简单的Demo</strong>来表达出我对这些变量的理解. 难免有偏差之处, 欢迎拍砖. 但是我能保证的是这些理解方式是<strong>实用</strong>的. 我个人也是看过网上很多日志对其有些微理解, 然后又通过写一个Demo来证明自己的想法. </p>
<hr>
<p>其实, 受过10几年教育的你, 必然知道, 一个二维矩形, 只要有了<code>{x,y,width,height}</code>, 也就唯一确定了它的几何属性. 没错, 其实<code>UIView</code>里面也就这几个变量. 其他变量, 比如<code>frame,bounds</code>都是这些变量通过基本变量导出的.那么<code>UIView</code>拥有的真正意义上的属性有哪些呢?</p>
<h2 id="UIView-真正意义上的属性"><a href="#UIView-真正意义上的属性" class="headerlink" title="UIView 真正意义上的属性:"></a>UIView 真正意义上的属性:</h2><ul>
<li><strong>bounds</strong>:<br><code>bounds</code>是一个<code>CGRect</code>. 他的size部分决定了<code>UIView</code>的大小,也就是,<code>bounds.width</code>和<code>bounds.height</code>决定了<code>UIView</code>的大小.你也可以说<code>bounds.width</code>和<code>bounds.height</code>就是<code>UIView</code>的<code>width</code>和<code>height</code>. <code>bounds.x</code>和<code>bounds.y</code>决定了<code>UIView</code>的<code>subView</code>的原点坐标.如果你更改了<code>bounds.x</code>或者<code>bounds.y</code>,<code>UIView</code>的位置和大小完全不为所动, 但是<code>UIView</code>的所有<code>subView</code>都会平移一段距离<code>(-bounds.x,-bounds.y)</code>(这一点我们会在下文做详细陈述).</li>
<li><strong>center</strong>:<br>望文生义(注意,这是个带贬义的词),他就是<code>UIView</code>的中心,也就是坐标点<code>(view.width/2,view.height/2)</code>.但是,可恶的但是, 上句话仅仅在在一个<code>UIView</code>刚被创建的时候成立. 也就是,在刚刚创建<code>UIView</code>的时候,他<strong>恰好</strong>成立. <strong>其实, <code>center</code>有它更重要的角色: 就是决定了<code>UIView</code>的位置.</strong> (但是,这个位置并不是我们常规意义上理解的<code>(x,y)</code>. 在这里你先知道它来决定我们UIView的位置就好了.)</li>
</ul>
<p>下面来看我们的第一个公式.</p>
<h2 id="揭开frame的本质"><a href="#揭开frame的本质" class="headerlink" title="揭开frame的本质"></a>揭开frame的本质</h2><p>我想,对于程序员的你,没有比比代码更直接的方式了吧?<br>下面就是<code>UIView</code>的属性<code>frame</code>的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码1</span><br><span class="line">-(CGRect) frame  </span><br><span class="line">&#123;  </span><br><span class="line">     float x &#x3D; center.x - 1&#x2F;2 * bounds.width;   </span><br><span class="line">     float y &#x3D; center.y - 1&#x2F;2 * bounds.height;  </span><br><span class="line">     float width &#x3D; bounds.width;</span><br><span class="line">     float height &#x3D; bounds.height;  </span><br><span class="line">     return CGRectMake(x, y, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void) setFrame:(CGRect) rect</span><br><span class="line">&#123;</span><br><span class="line">	center.x &#x3D; rect.x + 1&#x2F;2 * rect.width;</span><br><span class="line">	center.y &#x3D; rect.y + 1&#x2F;2 * rect.height;</span><br><span class="line">	bounds.width &#x3D; rect.width;</span><br><span class="line">	bounds.height &#x3D; rect.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来到实战演习:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码2</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">	testView &#x3D; [[UIView alloc] initWithFrame:CGRectMake(100, 100, 50, 50)];</span><br><span class="line">	testView.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">	[self.view insertSubview:testView atIndex:0];</span><br><span class="line">	</span><br><span class="line">	UIView* innerView &#x3D; [[UIView alloc] initWithFrame:CGRectMake(23,23, 4, 4)];</span><br><span class="line">	innerView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">	[testView addSubview:innerView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始状态,我们新建一个<code>UIView</code>,设置<code>frame</code>为<code>(100,100,50,50)</code>:<br>图1<br><img src="frame_images/IMG_0012.PNG" alt="Resize icon" title="初始状态图(1)">  </p>
<p>然后,我们改变<code>frame</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testView.frame &#x3D; CGRectMake(0,0,40,40); &#x2F;&#x2F;代码3</span><br></pre></td></tr></table></figure>
<p>我们再看看各个属性的变化:<br>图2<br><img src="frame_images/IMG_0013.PNG" alt="Resize icon" title="第一次设置frame(2)">  </p>
<p>没错,你看到了我们刚刚提到的<code>center</code>属性. 我们刚刚说过, 这个属性主要决定了<code>UIView</code>的位置. 所以当我们在<code>setFrame:</code>的时候会改变<code>UIView</code>的位置.<br>好吧, 既然我们见过<code>center</code>先生, 那就给您介绍一下吧, 也要给点面子是不?</p>
<h2 id="center如何搞定了位置"><a href="#center如何搞定了位置" class="headerlink" title="center如何搞定了位置?"></a>center如何搞定了位置?</h2><p><code>center</code>是<code>UIView</code>的相关属性中主要决定<code>UIView</code>位置(跟大小相对), 我们在图2的基础上, 改变center:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testView.center &#x3D; CGPointMake(125,125);&#x2F;&#x2F;代码4</span><br></pre></td></tr></table></figure>
<p>我们来看一下效果:<br>图3<br><img src="frame_images/IMG_0014.PNG" alt="Resize icon" title="第一次设置center(3)"><br>看到了吧? <code>testView</code>的位置向左下移动了<code>(125-20, 125-20)</code>距离.<br>根据<em>代码1</em>, 我们可以看到, <code>center</code>和<code>bounds</code>属性是相互独立的. 也就是他们中间某一个发生了变化, 不会影响另一个. 这说明了什么? 说明我们改变<code>center</code>的时候, 仅仅会改变<code>testView</code>的位置, 而它的大小不会有任何改变.</p>
<p>好了, 到这里, <code>testView</code>的<strong>位置</strong>和<strong>大小</strong>问题,我们已经彻底解决了.<br>但是对于<code>bounds</code>小伙儿, 我们只关注了它的<code>size</code>部分, 忽略了他的<code>origin</code>部分. 不好意思, <code>bounds</code>小伙, 现在才想起你.</p>
<h2 id="bounds的另一半"><a href="#bounds的另一半" class="headerlink" title="bounds的另一半"></a>bounds的另一半</h2><p>没图没真相, 我们首先来点料吧:<br>图4,图5<br><img src="frame_images/IMG_0015.PNG" alt="Resize icon" title="第一次设置bounds.origin(4)"> <img src="frame_images/IMG_0016.PNG" alt="Resize icon" title="第二次设置bounds.origin(5)"></p>
<p><code>bounds.origin</code>初始情况下为<code>(0,0)</code>. 我们设置  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testView.bounds &#x3D; CGRectMak(25,25,40,40); &#x2F;&#x2F;代码5</span><br></pre></td></tr></table></figure>
<p>得到左图.<br>我们没有改变<code>bounds.size</code>(仍然是40,40), 只是修改了<code>bounds.origin</code>: 从<code>(0,0)</code>改变成<code>(25,25)</code>.我们发现<code>testView</code>内部的小红点移动了<code>(0-25,0-25)</code>距离.(至于为设么这里是-25而不是25, 我也还没理解, 望高人指点.) 反正, 知道当你改变<code>bounds.origin</code>的时候, <code>testView</code>内部所有的<code>subView</code>都要想做相反方向的位移就对了. </p>
<p>在左图的基础上,再设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testView.bounds &#x3D; CGRectMak(-5,-5,40,40); &#x2F;&#x2F;代码6</span><br></pre></td></tr></table></figure>
<p>我们得到右图.</p>
<p>需要注意的是, 这里所有<code>subView</code>的<code>frame</code>是不会跟着改的, 还是原来的值. 我们可以这么理解: 设置<code>testView.origin</code>, 会改变所有孩子节点位置的基准点. 就比如, 我们把一辆车平移了, 我们站在路边发现车里的方向盘和发动机等子组件的位置都改变了, 而方向盘发动机等”子组件”相对于<strong>汽车的坐标</strong>没有改变.  </p>
<p>关于<code>bounds</code>, 还有一点要说: <strong>当你的<code>subView</code>的某些部分落在了<code>bounds</code>定义的矩形之外, 那么这些落在矩形之外的部分, 便不能接受任何点击,踩踏,横扫等事件了….</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ifdefine 欺骗 明明知道某个事实,却故意隐瞒或窜改并加以传播  </span><br><span class="line">写到这里, 我其实要跟大家道一个歉, 因为我在上面对frame的定义欺骗了大家.   </span><br><span class="line"># endif</span><br></pre></td></tr></table></figure>
<p><code>frame</code>的定义并没有这么简单, 因为还搀插着第三者的关系: <code>testView.layer.anchorPoint</code>.<br>有请 anchorPoint 出场!  </p>
<h2 id="在墙上钉个钉子-就是anchorPoint"><a href="#在墙上钉个钉子-就是anchorPoint" class="headerlink" title="在墙上钉个钉子,就是anchorPoint"></a>在墙上钉个钉子,就是anchorPoint</h2><p>好了,我们重新定义<code>frame</code>的<code>getter/setter</code>函数(其实就是把代码1的定义中所有的<code>1/2</code>改为<code>view.layer.anchorPoint</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码7</span><br><span class="line">-(CGRect) frame  </span><br><span class="line">&#123;  </span><br><span class="line">     float x &#x3D; center.x - layer.anchorPoint.x * bounds.width;   </span><br><span class="line">     float y &#x3D; center.y - layer.anchorPoint.y * bounds.height;  </span><br><span class="line">     float width &#x3D; bounds.width;</span><br><span class="line">     float height &#x3D; bounds.height;  </span><br><span class="line">     return CGRectMake(x, y, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void) setFrame:(CGRect) rect</span><br><span class="line">&#123;</span><br><span class="line">	center.x &#x3D; rect.x + layer.anchorPoint.x * rect.width;</span><br><span class="line">	center.y &#x3D; rect.y + layer.anchorPoint.y * rect.height;</span><br><span class="line">	bounds.width &#x3D; rect.width;</span><br><span class="line">	bounds.height &#x3D; rect.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>anchorPoint</code>的默认值是<code>(0.5,0.5)</code>,所以如果你不改变<code>anchorPoint</code>,那么<em>代码1</em>就是正确的. 之所以在<em>代码1</em>里撒了一个谎, 是因为不想那么早把<code>anchorPoint</code>引出来.<br>现在,你既然知道了<code>anchorPoint</code>跟<code>frame</code>之间的关系, 必然想知道它到底有什么用:  </p>
<p>先给你一个直观印象: <code>anchorPoint</code>就是一个钉子,把一幅画钉在墙上. 以后你想做什么转动也好, 把相框拉伸也好, 这个点是绝对不会动的.<br><code>anchorPoint</code>的默认值是<code>(0.5,0.5)</code>. 也就是说默认情况下,你对<code>testView</code>作旋转和缩放, 都会以<code>(bounds.size.width/2,bounds.size.height/2)</code>为基准点.下面我们接着图5来看一个转化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testView.transform &#x3D; CGAffineTransformMakeScale(2, 2);&#x2F;&#x2F;代码8</span><br></pre></td></tr></table></figure>
<p>视图如下:<br>图6<br><img src="frame_images/IMG_0020.PNG" alt="Resize icon" title="第一次设置scale=2(14)"><br>我们看到,<code>testView</code>以中心点位固定点,等比例扩大了一倍.<code>frame.origin</code>也移动了<code>(-20,-20)</code>. 跟我们的预期一样.<br><del>这里需要特别提醒各位的是:** 当对<code>testView</code>进行了<code>transform</code>之后,我们再去设置<code>frame</code>, <code>frame</code>已经完全不理咱们了. 也就是说<code>setFrame</code>函数完全不工作了.** 我们这个时候调用<code>frame</code>的<code>getter</code>函数, 得到的是transform后的大小.如上图所示,变成了<code>(85,85,80,80)</code>.</del><br>如果, 我们把<code>scale</code>恢复为1, 再改变<code>anchorPoint</code>的位置为<code>(0,0)</code>, 然后再把<code>testView</code>放大一倍(<code>scale=2</code>). 看看会发现什么:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码9</span><br><span class="line">testView.transform &#x3D; CGAffineTransformMakeScale(1, 1);</span><br><span class="line">testView.layer.anchorPoint &#x3D; CGPointMake(0,0)</span><br><span class="line">testView.transform &#x3D; CGAffineTransformMakeScale(2, 2);</span><br></pre></td></tr></table></figure>
<p>下面三个图分别对应上面三行代码执行后的状态:<br>图7,图8,图9<br><img src="frame_images/IMG_0017.PNG" alt="Resize icon" title="恢复scale=1(9)"> <img src="frame_images/IMG_0019.PNG" alt="Resize icon" title="设置anchorPoint=(0,0)(10)"><img src="frame_images/IMG_0022.PNG" alt="Resize icon" title="设置scale=2(18)"></p>
<p>对于上面的运行结果, 我有几点说明:   </p>
<ul>
<li>当我们改变<code>anchorPoint</code>的时候,<code>center</code>没有改变,那么根据<em>代码7</em>, <code>frame</code>也会随着发生改变. 您可以在图8中观察到这一变化.  </li>
<li>观察图8和图9的变化,你可以发现,这次缩放的中心点在左上角. 因为我们设置了<code>anchorPoint = CGPointMake(0,0)</code>.  </li>
<li>如果您是对图像做旋转, <code>anchorPoint</code>也是旋转的中心.</li>
</ul>
<p>到此为止, 文章开始提到的属性都基本讲完了. 只剩下了<code>layer.position</code>. 如果你细心, 你会发现上面所有的图片中, <code>layer.position === center</code>, 没错, 任何时候他们都是相等的.</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这里有博客中Demo的代码下载, 本博客中的所有截图都来自于Demo的截屏.如果我在博客中没有说明白, 您可以下载Demo仔细把玩. 相信你可以在实际操作中有更深刻的理解<br>Demo底部的输入框支持的的语法有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scale &#x3D; number</span><br><span class="line">center &#x3D; ( number, number )</span><br><span class="line">frame &#x3D; (number, number, number, number )</span><br><span class="line">bounds &#x3D; (number, number, number, number)</span><br><span class="line">center &#x3D; (number, number)</span><br><span class="line">position &#x3D; (number, number) &#x2F;&#x2F;layer.position</span><br><span class="line">anchorPoint &#x3D; (number, number) &#x2F;&#x2F;layer.anchorPoint</span><br></pre></td></tr></table></figure>
<p>比如您输入<code>frame =(0,0,40,40)</code>,就相当于执行代码<code>testView.frame = CGRectMake(0,0,40,40)</code>. 输入<code>center = (50,50)</code>就相当于执行代码<code>testView.center = CGPointMake(50,50)</code>.</p>
<p><a href="http://pan.baidu.com/s/1eiKZ0" target="_blank" rel="noopener" title="downlaod demo code">点此下载Demo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/08/08/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-2013/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/08/08/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-2013/" class="post-title-link" itemprop="url">[设计模式]创建型模式-2013</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-08-08 14:54:00" itemprop="dateCreated datePublished" datetime="2013-08-08T14:54:00+08:00">2013-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          阅读 Design Patterns - GoF 的笔记和感悟. 有些模式在表现上有相似之处, 或者在应用场合上的差异不是很明显. 我通过查阅其他资料, 加上自己的理解, 在此做一个总结.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2013/08/08/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-2013/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/07/26/%E6%8A%80%E6%9C%AF/[opencv]%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%86%E5%88%AB%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/07/26/%E6%8A%80%E6%9C%AF/%5Bopencv%5D%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%86%E5%88%AB%E5%99%A8/" class="post-title-link" itemprop="url">[opencv]训练自己的识别器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-07-26 16:06:00" itemprop="dateCreated datePublished" datetime="2013-07-26T16:06:00+08:00">2013-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          利用 haar 特征构建自己的识别器.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2013/07/26/%E6%8A%80%E6%9C%AF/%5Bopencv%5D%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%86%E5%88%AB%E5%99%A8/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://blog.bookbook.in/2013/07/22/%E6%8A%80%E6%9C%AF/[opencv]Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%BC%96%E8%AF%91openCV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="知明所以">
      <meta itemprop="description" content="关系、健康、自由，是我的追求。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Book Book, Come in~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2013/07/22/%E6%8A%80%E6%9C%AF/%5Bopencv%5DWindows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%BC%96%E8%AF%91openCV/" class="post-title-link" itemprop="url">[opencv]Windows平台下编译openCV</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-07-22 16:06:00" itemprop="dateCreated datePublished" datetime="2013-07-22T16:06:00+08:00">2013-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 13:00:17" itemprop="dateModified" datetime="2019-01-13T13:00:17+08:00">2019-01-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>简介: 从官网上下载的 opencv 包里有为windows平台编译好的现成的 *.dll 文件, 可以在我们的项目中使用. 但是如果我们要训练自己的 分类器, 就需要用到 haartraining 等工具. 这些工具需要我们自己编译. 本文详细讲解了这一过程</p>
<p>见<a href="http://www.cnblogs.com/jhzhu/p/3216840.html" target="_blank" rel="noopener">http://www.cnblogs.com/jhzhu/p/3216840.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">知明所以</p>
  <div class="site-description" itemprop="description">关系、健康、自由，是我的追求。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">236</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zjh1943" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zjh1943" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jhzhuustc@gmail.com" title="E-Mail → mailto:jhzhuustc@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">知明所以</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
