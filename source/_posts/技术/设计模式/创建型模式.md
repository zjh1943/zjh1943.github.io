---
title: "[设计模式]创建型模式"
date: 2016-03-07 18:05
tags:
- 设计模式
- design
- pattern
- creational
- factory
- method
- abstract
- singlton
categories: 
- 技术
---


摘要：设计模式并不能减小系统的复杂度，并不能减少`if...else...`。它只是帮助把代码放在适当的位置，以便在需求更改时改动的代码最少。


## 简单工厂模式

* 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
* 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
* 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。


![](SimpleFactory.jpg)

## 工厂方法模式

本质上说就是产品创建功能的下放，交给子类去做。

* 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。
* 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。

![](FactoryMethod.jpg)

## 抽象工厂模式


最重要的概念：**产品族**。
抽象工厂模式适用情况包括：  

* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；
* 系统中有多于一个的产品族，而每次只使用其中某一产品族；
* 属于同一个产品族的产品将在一起使用；
* 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

![](AbatractFactory.jpg)

## 建造者模式

* 在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。
* 建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。
* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

![](Builder.jpg)


## 单例模式

（略）

## 原型模式

关键字： `- clone();`;


## 区分

1. 抽象工厂模式与建造者模式相似，都可以创建组复杂对象。主要的区别是Builder模式着重于一步步构建一个复杂对象。而Abstract Factory着重于多个系列的产品对象。Builder在最后一步返回产品（封装了产品的构建），而对于Abstract Factory来说，产品是立即返回的。
